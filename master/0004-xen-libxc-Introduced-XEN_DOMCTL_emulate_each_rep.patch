From 184ba3e134de1f47d09e2c8f304b66ddab3172f6 Mon Sep 17 00:00:00 2001
From: Razvan Cojocaru <rcojocaru@bitdefender.com>
Date: Mon, 14 Sep 2015 15:30:35 +0300
Subject: [PATCH 4/6] xen, libxc: Introduced XEN_DOMCTL_emulate_each_rep

Previously, if vm_event emulation support was enabled, then REP
optimizations were disabled when emulating REP-compatible
instructions. This patch allows fine-tuning of this behaviour by
providing a dedicated libxc helper function.

Signed-off-by: Razvan Cojocaru <rcojocaru@bitdefender.com>
---
 tools/libxc/include/xenctrl.h    | 11 +++++++++++
 tools/libxc/xc_domain.c          | 17 +++++++++++++++++
 xen/arch/x86/hvm/emulate.c       |  2 +-
 xen/common/domctl.c              |  5 +++++
 xen/include/asm-x86/hvm/domain.h |  1 +
 xen/include/public/domctl.h      |  8 ++++++++
 6 files changed, 43 insertions(+), 1 deletion(-)

diff --git a/tools/libxc/include/xenctrl.h b/tools/libxc/include/xenctrl.h
index bb42667..c7db4e2 100644
--- a/tools/libxc/include/xenctrl.h
+++ b/tools/libxc/include/xenctrl.h
@@ -654,6 +654,17 @@ int xc_domain_node_getaffinity(xc_interface *xch,
                                xc_nodemap_t nodemap);
 
 /**
+ * This function enables / disables emulation for each REP for a
+ * REP-compatible instruction.
+ *
+ * @parm xch a handle to an open hypervisor interface.
+ * @parm domid the domain id one wants to get the node affinity of.
+ * @parm enable if 0 optimize when possible, else emulate each REP.
+ * @return 0 on success, -1 on failure.
+ */
+int xc_domain_emulate_each_rep(xc_interface *xch, uint32_t domid, int enable);
+
+/**
  * This function specifies the CPU affinity for a vcpu.
  *
  * There are two kinds of affinity. Soft affinity is on what CPUs a vcpu
diff --git a/tools/libxc/xc_domain.c b/tools/libxc/xc_domain.c
index 7301a10..068ae5e 100644
--- a/tools/libxc/xc_domain.c
+++ b/tools/libxc/xc_domain.c
@@ -2674,6 +2674,23 @@ int xc_domain_trigger_sleep(xc_interface *xch, unsigned int domid)
     return ret;
 }
 
+int xc_domain_emulate_each_rep(xc_interface *xch, uint32_t domid, int enable)
+{
+    int ret = -1;
+    DECLARE_DOMCTL;
+
+    domctl.cmd = XEN_DOMCTL_emulate_each_rep;
+    domctl.domain = (domid_t)domid;
+    domctl.u.emulate_each_rep.op = enable;
+
+    ret = do_domctl(xch, &domctl);
+
+    if ( ret == -ESRCH )
+        errno = ENOENT;
+
+    return ret;
+}
+
 /*
  * Local variables:
  * mode: C
diff --git a/xen/arch/x86/hvm/emulate.c b/xen/arch/x86/hvm/emulate.c
index f5ee544..3b402e1 100644
--- a/xen/arch/x86/hvm/emulate.c
+++ b/xen/arch/x86/hvm/emulate.c
@@ -514,7 +514,7 @@ static int hvmemul_virtual_to_linear(
      * being triggered for repeated writes to a whole page.
      */
     *reps = min_t(unsigned long, *reps,
-                  unlikely(current->domain->arch.mem_access_emulate_enabled)
+                  unlikely(current->domain->arch.hvm_domain.emulate_each_rep)
                            ? 1 : 4096);
 
     reg = hvmemul_get_seg_reg(seg, hvmemul_ctxt);
diff --git a/xen/common/domctl.c b/xen/common/domctl.c
index 4ebb06f..80e0120 100644
--- a/xen/common/domctl.c
+++ b/xen/common/domctl.c
@@ -1202,6 +1202,11 @@ long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)
         break;
     }
 
+    case XEN_DOMCTL_emulate_each_rep:
+        d->arch.hvm_domain.emulate_each_rep = !!op->u.emulate_each_rep.op;
+        ret = 0;
+        break;
+
     default:
         ret = arch_do_domctl(op, d, u_domctl);
         break;
diff --git a/xen/include/asm-x86/hvm/domain.h b/xen/include/asm-x86/hvm/domain.h
index 2cf69b2..22f8647 100644
--- a/xen/include/asm-x86/hvm/domain.h
+++ b/xen/include/asm-x86/hvm/domain.h
@@ -136,6 +136,7 @@ struct hvm_domain {
     bool_t                 mem_sharing_enabled;
     bool_t                 qemu_mapcache_invalidate;
     bool_t                 is_s3_suspended;
+    bool_t                 emulate_each_rep;
 
     /*
      * TSC value that VCPUs use to calculate their tsc_offset value.
diff --git a/xen/include/public/domctl.h b/xen/include/public/domctl.h
index 011ae43..b8049f7 100644
--- a/xen/include/public/domctl.h
+++ b/xen/include/public/domctl.h
@@ -1063,6 +1063,12 @@ struct xen_domctl_psr_cat_op {
 typedef struct xen_domctl_psr_cat_op xen_domctl_psr_cat_op_t;
 DEFINE_XEN_GUEST_HANDLE(xen_domctl_psr_cat_op_t);
 
+struct xen_domctl_emulate_each_rep {
+    int32_t op;
+};
+typedef struct xen_domctl_emulate_each_rep xen_domctl_emulate_each_rep_t;
+DEFINE_XEN_GUEST_HANDLE(xen_domctl_emulate_each_rep_t);
+
 /*
  * Return information about the state and running time of a domain.
  * The "domain runstate" is based on the runstates of all the vcpus of the
@@ -1186,6 +1192,7 @@ struct xen_domctl {
 #define XEN_DOMCTL_psr_cmt_op                    75
 #define XEN_DOMCTL_monitor_op                    77
 #define XEN_DOMCTL_psr_cat_op                    78
+#define XEN_DOMCTL_emulate_each_rep              80
 #define XEN_DOMCTL_get_runstate_info             98
 #define XEN_DOMCTL_gdbsx_guestmemio            1000
 #define XEN_DOMCTL_gdbsx_pausevcpu             1001
@@ -1252,6 +1259,7 @@ struct xen_domctl {
         struct xen_domctl_psr_cmt_op        psr_cmt_op;
         struct xen_domctl_monitor_op        monitor_op;
         struct xen_domctl_psr_cat_op        psr_cat_op;
+        struct xen_domctl_emulate_each_rep  emulate_each_rep;
         uint8_t                             pad[128];
     } u;
 };
-- 
2.5.2

